<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My Codes</title>
    <style>
        body { font-family: Arial, sans-serif; background: #f5f5f5; padding: 20px; }
        h1 { color: #0077cc; }
        .snippet { background: #222; color: #eee; padding: 16px; border-radius: 8px; margin-bottom: 24px; font-size: 16px; }
        .snippet code { white-space: pre-wrap; font-family: 'Fira Mono', 'Consolas', monospace; }
    </style>
</head>
<body>
    <h1>My Code Snippets</h1>

       

    <div class="snippet">
        <b>FCFS & SJF:</b>
        <pre><code>
FCFS 
n = int(input("Enter number of processes: "))
processes = []

# Input arrival and burst times
for i in range(n):
    at = int(input(f"Enter arrival time for Process {i+1}: "))
    bt = int(input(f"Enter burst time for Process {i+1}: "))
    processes.append((f"P{i+1}", at, bt))

# Sort by arrival time
processes.sort(key=lambda x: x[1])

start_time = []
finish_time = []
waiting_time = []
turnaround_time = []

# Calculate start, finish, waiting and turnaround times
for i, (p, at, bt) in enumerate(processes):
    if i == 0:
        st = at
    else:
        st = max(at, finish_time[i-1])
    ft = st + bt
    wt = st - at
    tat = ft - at
    
    start_time.append(st)
    finish_time.append(ft)
    waiting_time.append(wt)
    turnaround_time.append(tat)

# Calculate averages
avg_wt = sum(waiting_time) / n
avg_tat = sum(turnaround_time) / n

# Display results
print("\nProcess\tAT\tBT\tST\tFT\tWT\tTAT")
for i in range(n):
    p, at, bt = processes[i]
    print(f"{p}\t{at}\t{bt}\t{start_time[i]}\t{finish_time[i]}"
          f"\t{waiting_time[i]}\t{turnaround_time[i]}")

print(f"\nAverage Waiting Time: {avg_wt:.2f}")
print(f"Average Turnaround Time: {avg_tat:.2f}")






SJF
n = int(input("Enter number of processes: "))
processes = []

# Input arrival and burst times
for i in range(n):
    at = int(input(f"Enter arrival time for Process {i+1}: "))
    bt = int(input(f"Enter burst time for Process {i+1}: "))
    processes.append((f"P{i+1}", at, bt))

# Initialize variables
completed = 0
current_time = 0
start_time = [0] * n
finish_time = [0] * n
waiting_time = [0] * n
turnaround_time = [0] * n
is_completed = [False] * n

while completed < n:
    # Find process with shortest burst time at or before current_time
    idx = -1
    min_bt = float('inf')
    for i in range(n):
        p, at, bt = processes[i]
        if (at <= current_time) and (not is_completed[i]) and (bt < min_bt):
            min_bt = bt
            idx = i

    if idx == -1:
        current_time += 1  # No process available, increment time
    else:
        p, at, bt = processes[idx]
        start_time[idx] = current_time
        finish_time[idx] = start_time[idx] + bt
        waiting_time[idx] = start_time[idx] - at
        turnaround_time[idx] = finish_time[idx] - at
        current_time = finish_time[idx]
        is_completed[idx] = True
        completed += 1

# Calculate averages
avg_wt = sum(waiting_time) / n
avg_tat = sum(turnaround_time) / n

# Display results
print("\nProcess\tAT\tBT\tST\tFT\tWT\tTAT")
for i in range(n):
    p, at, bt = processes[i]
    print(f"{p}\t{at}\t{bt}\t{start_time[i]}\t{finish_time[i]}"
          f"\t{waiting_time[i]}\t{turnaround_time[i]}")

print(f"\nAverage Waiting Time: {avg_wt:.2f}")
print(f"Average Turnaround Time: {avg_tat:.2f}")
    }
}
        </code></pre>
    </div>



<div class="snippet">
        <b>ROUND ROBIN:</b>
        <pre><code>
ROUND ROBIN 
# Program to implement Round Robin CPU Scheduling Algorithm
# Step 1: Start
# Step 2: Declare the array size (not explicitly needed in Python, we'll use lists)
# Step 3: Read the number of processes
n = int(input("Enter the number of processes: "))
# Step 4: Read the burst times of the processes
burst_times = []
processes = []
for i in range(n):
    processes.append(f"P{i+1}")
    bt = int(input(f"Enter burst time for process {processes[i]}: "))
    burst_times.append(bt)
# Step 5: Read the Time Quantum
time_quantum = int(input("Enter the time quantum: "))
# Step 6: Simulate Round Robin scheduling
# We'll use a loop to handle the scheduling until all processes are completed
remaining_burst = burst_times.copy()
waiting_time = [0] * n
turnaround_time = [0] * n
current_time = 0
completed = 0
while completed < n:
    done_in_this_cycle = False
    for i in range(n):
        if remaining_burst[i] > 0:
            done_in_this_cycle = True
            if remaining_burst[i] > time_quantum:
                # Subtract time quantum from burst time
                current_time += time_quantum
                remaining_burst[i] -= time_quantum
            else:
                # Assign the remaining burst time and complete the process
                current_time += remaining_burst[i]
                waiting_time[i] = current_time - burst_times[i]
                remaining_burst[i] = 0
                completed += 1
    if not done_in_this_cycle:
        break
# Step 7: Calculate turnaround times and averages
for i in range(n):
    turnaround_time[i] = burst_times[i] + waiting_time[i]
avg_waiting_time = sum(waiting_time) / n
avg_turnaround_time = sum(turnaround_time) / n
# Step 8: Display the values
print("\nProcess\tBurst Time\tWaiting Time\tTurnaround Time")
for i in range(n):
    print(f"{processes[i]}\t{burst_times[i]}\t\t{waiting_time[i]}\t\t{turnaround_time[i]}")
print(f"\nAverage Waiting Time: {avg_waiting_time}")
print(f"Average Turnaround Time: {avg_turnaround_time}")
# Step 9: Stop
        </code></pre>
    </div>



<div class="snippet">
        <b>BANKERS ALGO</b>
        <pre><code>
BANKERâ€™S ALGORITHM 
def is_safe_state(processes, available, max_demand, allocation):
    n = len(processes)
    m = len(available)

    # Calculate need matrix
    need = [[max_demand[i][j] - allocation[i][j] for j in range(m)] for i in range(n)]

    finish = [False] * n
    safe_sequence = []
    work = available.copy()

    while len(safe_sequence) < n:
        allocated_in_this_round = False

        for i in range(n):
            if not finish[i]:
                if all(need[i][j] <= work[j] for j in range(m)):
                    for j in range(m):
                        work[j] += allocation[i][j]

                    finish[i] = True
                    safe_sequence.append(processes[i])
                    allocated_in_this_round = True

        if not allocated_in_this_round:
            return False, []

    return True, safe_sequence

def main():
    print("Banker's Algorithm Implementation")

    n = int(input("Enter number of processes: "))
    m = int(input("Enter number of resource types: "))

    processes = ["P" + str(i) for i in range(n)]

    print("\nEnter Allocation Matrix (space separated values row-wise):")
    allocation = []
    for i in range(n):
        row = list(map(int, input(f"Allocation for {processes[i]}: ").strip().split()))
        allocation.append(row)

    print("\nEnter Maximum Demand Matrix (space separated values row-wise):")
    max_demand = []
    for i in range(n):
        row = list(map(int, input(f"Max demand for {processes[i]}: ").strip().split()))
        max_demand.append(row)

    print("\nEnter Available Resources (space separated):")
    available = list(map(int, input("Available: ").strip().split()))

    # Input validation
    if any(len(row) != m for row in allocation + max_demand) or len(available) != m:
        print("\nError: Incorrect number of resource types entered.")
        return

    safe, sequence = is_safe_state(processes, available, max_demand, allocation)
    if safe:
        print("\nThe system is in a safe state.")
        print("Safe sequence:", " -> ".join(sequence))
    else:
        print("\nThe system is NOT in a safe state.")

if __name__ == "__main__":
    main()


        </code></pre>
    </div>


 <div class="snippet">
        <b>MEMORY ALLOCATION</b>
        <pre><code>
MEMORY ALLOCATION [ FITS ]
def allocate(method, blocks, procs):
    print(f"\n{method.upper()} FIT ALGORITHM:")
    total_waste = 0
    memory = blocks[:]

    for i, p in enumerate(procs):
        idx = -1

        if method == "first":
            for j, b in enumerate(memory):
                if p <= b:
                    idx = j
                    break

        elif method == "best":
            fits = [(j, b - p) for j, b in enumerate(memory) if b >= p]
            if fits:
                idx, waste = min(fits, key=lambda x: x[1])

        elif method == "worst":
            fits = [(j, b - p) for j, b in enumerate(memory) if b >= p]
            if fits:
                idx, waste = max(fits, key=lambda x: x[1])

        if idx != -1:
            waste = memory[idx] - p
            memory[idx] -= p
            total_waste += waste
            print(f"Process {i+1} -> Block {idx+1} (Waste = {waste})")
        else:
            print(f"Process {i+1} not allocated.")

    print("Total Waste:", total_waste)

if __name__ == "__main__":
    m = int(input("Enter number of blocks: "))
    blocks = [int(input(f"Block {i+1} size: ")) for i in range(m)]

    n = int(input("Enter number of processes: "))
    procs = [int(input(f"Process {i+1} size: ")) for i in range(n)]

    allocate("first", blocks.copy(), procs)
    allocate("best", blocks.copy(), procs)
    allocate("worst", blocks.copy(), procs)


        </code></pre>
    </div>



<div class="snippet">
        <b>PAGE REPLACEMENT</b>
        <pre><code>
PAGE REPLACEMENT ALGORITHM 
def fifo(requests, total_frames):
    print("\n__________FIRST IN FIRST OUT__________")
    frames = []
    victim = 0
    faults = 0

    for r in requests:
        if r not in frames:
            if len(frames) < total_frames:
                frames.append(r)
            else:
                frames[victim] = r
            victim = (victim + 1) % total_frames
            faults += 1

    print("Final Status:", frames)
    print("Page Faults:", faults)


def optimal(requests, total_frames):
    print("\n__________OPTIMAL ALGORITHM__________")
    frames = []
    faults = 0

    for i in range(len(requests)):
        page = requests[i]
        if page not in frames:
            faults += 1
            if len(frames) < total_frames:
                frames.append(page)
            else:
                future = [float("inf")] * len(frames)
                for j, f in enumerate(frames):
                    if f in requests[i+1:]:
                        future[j] = requests[i+1:].index(f) + i + 1
                replace_idx = future.index(max(future))
                frames[replace_idx] = page
    print("Final Status:", frames)
    print("Page Faults:", faults)


def lru(requests, total_frames):
    print("\n__________LEAST RECENTLY USED (LRU)__________")
    frames = []
    faults = 0

    for i in range(len(requests)):
        page = requests[i]
        if page not in frames:
            faults += 1
            if len(frames) < total_frames:
                frames.append(page)
            else:
                past = [-1] * len(frames)
                for j, f in enumerate(frames):
                    if f in requests[:i]:
                        past[j] = len(requests[:i]) - 1 - requests[:i][::-1].index(f)
                replace_idx = past.index(min(past))
                frames[replace_idx] = page
    print("Final Status:", frames)
    print("Page Faults:", faults)


if __name__ == "__main__":
    # Predefined page requests and frame count
    requests = [1, 0, 5, 1, 1, 3, 5, 1, 5, 3, 4, 5, 2, 1, 3, 0, 1, 4, 0, 5]
    total_frames = 3

    fifo(requests, total_frames)
    optimal(requests, total_frames)
    lru(requests, total_frames)

        </code></pre>
    </div>


<div class="snippet">
        <b>IO SCHEDULING</b>
        <pre><code>
I/O SCHEDULING ALGO 
def fcfs(queue, head):
    print("\n__________FCFS__________")
    total = 0
    for req in queue:
        total += abs(head - req)
        head = req
    print("Total Head Movement:", total)
    print("Average Seek Length:", total / len(queue))


def sstf(queue, head):
    print("\n__________SSTF__________")
    total = 0
    q = queue.copy()
    while q:
        closest = min(q, key=lambda x: abs(x - head))
        total += abs(head - closest)
        head = closest
        q.remove(closest)
    print("Total Head Movement:", total)
    print("Average Seek Length:", total / len(queue))


def scan(queue, head, disk_size, direction):
    print("\n__________SCAN (" + direction.upper() + ")__________")
    q = sorted(queue)
    left = [r for r in q if r < head]
    right = [r for r in q if r >= head]
    seq = []

    if direction == "left":
        seq = left[::-1] + [0] + right
    else:
        seq = right + [disk_size - 1] + left[::-1]

    total = 0
    for req in seq:
        total += abs(head - req)
        head = req
    print("Total Head Movement:", total)
    print("Average Seek Length:", total / len(seq))


if __name__ == "__main__":
    queue = [55, 58, 39, 18, 90, 160, 150, 38, 184]
    head = 100
    disk_size = 200

    fcfs(queue, head)
    sstf(queue, head)
    scan(queue, head, disk_size, "left")



        </code></pre>
    </div>





    <div class="snippet">
        <b>Python Example:</b>
        <pre><code>
def greet():
    print("Hello from Python!")
greet()
        </code></pre>
    </div>

    <!-- Add more snippets here -->
</body>
</html>
